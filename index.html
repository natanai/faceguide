<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FaceGuide — Overlay Alignment</title>
<style>
:root { --fg:#111; --muted:#666; --bg:#fff; --line:#ddd; --accent:#005bd1; --pill:#eef4ff; }
* { box-sizing: border-box; }
body { margin: 16px; color: var(--fg); background: var(--bg); font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
header { margin-bottom: 12px; }
h1 { font-size: 1.25rem; margin: 0 0 6px; }
h2 { font-size: 1rem; margin: 0 0 6px; }
a { color: var(--accent); text-decoration: none; }
a:hover { text-decoration: underline; }
.panel { border: 1px solid var(--line); border-radius: 10px; padding: 16px; max-width: 960px; margin: 0 auto; background: #fff; }
.hero { display: flex; flex-wrap: wrap; gap: 16px; margin: 16px 0 24px; }
.hero-card { flex: 1 1 280px; border: 1px solid var(--line); border-radius: 12px; padding: 16px; background: #f7f9ff; }
.hero-card p { margin: 0 0 12px; font-size: 14px; line-height: 1.45; }
.cta-btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 999px; background: var(--accent); color: #fff; font-weight: 600; text-decoration: none; }
.cta-btn:hover { text-decoration: none; background: #0046a5; }
.hero-card .muted { color: var(--muted); margin: 0; }
.controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
.controls label { font-size: 14px; display: flex; align-items: center; gap: 6px; }
.controls input[type="range"] { width: 140px; }
.controls .control-value { min-width: 44px; text-align: right; font-variant-numeric: tabular-nums; }
.controls-manual { margin-top: -4px; }
.controls-manual label { min-width: 200px; }
.controls button { padding: 6px 12px; border-radius: 6px; border: 1px solid var(--accent); background: var(--pill); color: var(--accent); cursor: pointer; }
.controls button:disabled { opacity: 0.5; cursor: not-allowed; }
.small { font-size: 12px; }
.muted { color: var(--muted); }
.wrap { position: relative; width: 100%; border: 1px solid var(--line); border-radius: 8px; overflow: hidden; background: #f8f8f8; }
canvas { display: block; width: 100%; height: auto; }
.status-ok { color: #1a7f3b; }
.status-warn { color: #b36b00; }
.dot-label { position: absolute; font-size: 12px; padding: 2px 6px; background: rgba(0,0,0,0.6); color: #fff; border-radius: 6px; transform: translate(-50%, -50%); pointer-events: none; }
</style>
</head>
<body>
<header>
  <h1>FaceGuide — Overlay Alignment</h1>
  <p class="muted">Align your saved target portrait over the comparison feed using the landmarks you placed.</p>
  <div class="hero">
    <div class="hero-card">
      <h2>1. Load your faces</h2>
      <p>Upload the target portrait, capture or upload the comparison face, and drop matching landmarks in the Manual Landmark Setup. Everything is saved automatically for this overlay view.</p>
      <a class="cta-btn" href="manual.html">Open Manual Landmark Setup →</a>
      <p class="muted small">Use this whenever you need to change the images or adjust pins.</p>
    </div>
    <div class="hero-card">
      <h2>2. Align the overlay</h2>
      <p>Return here once both faces have at least three matching points. Adjust opacity, offsets, scale, or rotation to fine-tune asymmetrical features.</p>
      <p class="muted small">Saved uploads and landmarks appear here immediately.</p>
    </div>
  </div>
</header>
<main class="panel">
  <div class="controls">
    <label>Overlay opacity
      <input type="range" id="opacity" min="0" max="100" value="50" />
      <span id="opacityVal">50%</span>
    </label>
    <label><input type="checkbox" id="showPoints" checked /> Show control points</label>
    <button id="startCapture">Start live capture</button>
    <button id="stopCapture" disabled>Stop</button>
    <button id="freezeCapture" disabled>Freeze frame</button>
  </div>
  <div class="controls controls-manual">
    <label>Horizontal offset
      <input type="range" id="offsetX" min="-250" max="250" value="0" />
      <span id="offsetXVal" class="control-value">0px</span>
    </label>
    <label>Vertical offset
      <input type="range" id="offsetY" min="-250" max="250" value="0" />
      <span id="offsetYVal" class="control-value">0px</span>
    </label>
    <label>Scale
      <input type="range" id="scale" min="80" max="120" value="100" />
      <span id="scaleVal" class="control-value">100%</span>
    </label>
    <label>Rotation
      <input type="range" id="rotation" min="-20" max="20" value="0" />
      <span id="rotationVal" class="control-value">0°</span>
    </label>
    <button id="resetAdjust">Reset adjustments</button>
  </div>
  <div id="status" class="muted small"></div>
  <div class="wrap" id="canvasWrap">
    <canvas id="overlayCanvas"></canvas>
  </div>
</main>
<video id="captureVideo" autoplay muted playsinline style="display:none;"></video>
<script>
(function(){
  const STATE_KEY = 'faceguide_overlay_state_v1';
  const MANUAL_KEY = 'faceguide_overlay_manual_adjust_v1';
  const canvas = document.getElementById('overlayCanvas');
  const ctx = canvas.getContext('2d');
  const wrap = document.getElementById('canvasWrap');
  const opacitySlider = document.getElementById('opacity');
  const opacityVal = document.getElementById('opacityVal');
  const showPointsChk = document.getElementById('showPoints');
  const statusEl = document.getElementById('status');
  const startBtn = document.getElementById('startCapture');
  const stopBtn = document.getElementById('stopCapture');
  const freezeBtn = document.getElementById('freezeCapture');
  const captureVideo = document.getElementById('captureVideo');
  const offsetXSlider = document.getElementById('offsetX');
  const offsetYSlider = document.getElementById('offsetY');
  const scaleSlider = document.getElementById('scale');
  const rotationSlider = document.getElementById('rotation');
  const offsetXVal = document.getElementById('offsetXVal');
  const offsetYVal = document.getElementById('offsetYVal');
  const scaleVal = document.getElementById('scaleVal');
  const rotationVal = document.getElementById('rotationVal');
  const resetAdjustBtn = document.getElementById('resetAdjust');

  const refImg = new Image();
  const baseImg = new Image();
  let refReady = false;
  let baseReady = false;
  let overlayOpacity = 0.5;
  let showPoints = true;
  let viewA = null;
  let viewB = null;
  let pointsA = {};
  let pointsB = {};
  let controlIds = ['left_pupil','right_pupil','nose_tip'];
  let stateLoaded = false;
  let storageTruncated = false;
  let pendingImages = false;
  const manualDefaults = {offsetX:0, offsetY:0, scale:1, rotation:0};
  const manualAdjust = {...manualDefaults};

  const captureState = { stream:null, active:false, naturalWidth:0, naturalHeight:0, rafId:0 };

  function manualIsNeutral(){
    return Math.abs(manualAdjust.offsetX) < 0.5 &&
      Math.abs(manualAdjust.offsetY) < 0.5 &&
      Math.abs(manualAdjust.scale - 1) < 0.002 &&
      Math.abs(manualAdjust.rotation) < 0.1;
  }

  function manualIsActive(){
    return !manualIsNeutral();
  }

  function updateManualLabels(){
    offsetXVal.textContent = Math.round(manualAdjust.offsetX) + 'px';
    offsetYVal.textContent = Math.round(manualAdjust.offsetY) + 'px';
    scaleVal.textContent = Math.round(manualAdjust.scale * 100) + '%';
    rotationVal.textContent = Math.round(manualAdjust.rotation) + '°';
    resetAdjustBtn.disabled = manualIsNeutral();
  }

  function applyManualToSliders(){
    offsetXSlider.value = manualAdjust.offsetX;
    offsetYSlider.value = manualAdjust.offsetY;
    scaleSlider.value = Math.round(manualAdjust.scale * 100);
    rotationSlider.value = manualAdjust.rotation;
    updateManualLabels();
  }

  function saveManualAdjustments(){
    try {
      const payload = {
        offsetX: manualAdjust.offsetX,
        offsetY: manualAdjust.offsetY,
        scale: manualAdjust.scale,
        rotation: manualAdjust.rotation
      };
      window.localStorage.setItem(MANUAL_KEY, JSON.stringify(payload));
    } catch(err){
      console.warn('Failed to save manual overlay adjustments', err);
    }
  }

  function loadManualAdjustments(){
    try {
      const raw = window.localStorage.getItem(MANUAL_KEY);
      if(raw){
        const data = JSON.parse(raw);
        if(data && typeof data === 'object'){
          if(typeof data.offsetX === 'number'){ manualAdjust.offsetX = clamp(data.offsetX, -250, 250); }
          if(typeof data.offsetY === 'number'){ manualAdjust.offsetY = clamp(data.offsetY, -250, 250); }
          if(typeof data.scale === 'number'){ manualAdjust.scale = clamp(data.scale, 0.8, 1.2); }
          if(typeof data.rotation === 'number'){ manualAdjust.rotation = clamp(data.rotation, -20, 20); }
        }
      }
    } catch(err){
      console.warn('Failed to load manual overlay adjustments', err);
    }
    applyManualToSliders();
  }

  function updateManualFromInputs(){
    manualAdjust.offsetX = clamp(parseFloat(offsetXSlider.value) || 0, -250, 250);
    manualAdjust.offsetY = clamp(parseFloat(offsetYSlider.value) || 0, -250, 250);
    manualAdjust.scale = clamp((parseFloat(scaleSlider.value) || 100) / 100, 0.8, 1.2);
    manualAdjust.rotation = clamp(parseFloat(rotationSlider.value) || 0, -20, 20);
    updateManualLabels();
    saveManualAdjustments();
    drawOnce();
  }

  function resetManualAdjustments(){
    manualAdjust.offsetX = manualDefaults.offsetX;
    manualAdjust.offsetY = manualDefaults.offsetY;
    manualAdjust.scale = manualDefaults.scale;
    manualAdjust.rotation = manualDefaults.rotation;
    applyManualToSliders();
    saveManualAdjustments();
    drawOnce();
  }

  function composeManualTransform(base){
    if(!base) return null;
    const s = manualAdjust.scale;
    const r = manualAdjust.rotation * Math.PI / 180;
    const cr = Math.cos(r);
    const sr = Math.sin(r);
    const dx = manualAdjust.offsetX;
    const dy = manualAdjust.offsetY;
    const baseA = base.a;
    const baseB = base.b;
    const baseC = -base.b;
    const baseD = base.a;
    const baseE = base.tx;
    const baseF = base.ty;

    const m00 = s * cr;
    const m01 = -s * sr;
    const m02 = dx;
    const m10 = s * sr;
    const m11 = s * cr;
    const m12 = dy;

    const outA = m00 * baseA + m01 * baseB;
    const outB = m10 * baseA + m11 * baseB;
    const outC = m00 * baseC + m01 * baseD;
    const outD = m10 * baseC + m11 * baseD;
    const outE = m00 * baseE + m01 * baseF + m02;
    const outF = m10 * baseE + m11 * baseF + m12;

    return { a: outA, b: outB, c: outC, d: outD, e: outE, f: outF };
  }

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function naturalSize(which){
    if(which==='A'){
      return {w: refImg.naturalWidth || 0, h: refImg.naturalHeight || 0};
    }
    if(captureState.active){
      return {
        w: captureState.naturalWidth || captureVideo.videoWidth || 0,
        h: captureState.naturalHeight || captureVideo.videoHeight || 0
      };
    }
    return {w: baseImg.naturalWidth || 0, h: baseImg.naturalHeight || 0};
  }

  function boundingBox(points, ids, dims){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity, count=0;
    ids.forEach(id=>{
      const p = points[id];
      if(!p) return;
      const x = p.u * (dims.w||0);
      const y = p.v * (dims.h||0);
      if(!isFinite(x) || !isFinite(y)) return;
      minX=Math.min(minX,x); maxX=Math.max(maxX,x);
      minY=Math.min(minY,y); maxY=Math.max(maxY,y);
      count++;
    });
    if(!count || !isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return null;
    const w=Math.max(1, maxX-minX);
    const h=Math.max(1, maxY-minY);
    return {x:minX, y:minY, w, h, cx:minX+w/2, cy:minY+h/2};
  }

  function paddedBox(box, dims){
    if(!box) return null;
    const base = Math.max(box.w, box.h);
    const pad = base * 0.25;
    const minSize = Math.min(dims.w || 0, dims.h || 0) * 0.25;
    let w = box.w + pad * 2;
    let h = box.h + pad * 2;
    if(minSize){
      w = Math.max(w, minSize);
      h = Math.max(h, minSize);
    }
    if(dims.w){ w = Math.min(w, dims.w); }
    if(dims.h){ h = Math.min(h, dims.h); }
    return {cx: box.cx, cy: box.cy, w: Math.max(1,w), h: Math.max(1,h)};
  }

  function alignBox(box, targetW, targetH, dims){
    if(!box) return null;
    let w = Math.min(targetW, dims.w || targetW);
    let h = Math.min(targetH, dims.h || targetH);
    w = Math.max(1, w);
    h = Math.max(1, h);
    let x = box.cx - w/2;
    let y = box.cy - h/2;
    if(dims.w){
      if(x < 0) x = 0;
      if(x + w > dims.w) x = Math.max(0, dims.w - w);
    }
    if(dims.h){
      if(y < 0) y = 0;
      if(y + h > dims.h) y = Math.max(0, dims.h - h);
    }
    return {x, y, w, h};
  }

  function sharedIds(){
    const ids = [];
    const seen = new Set();
    Object.keys(pointsA).forEach(id=>{ if(pointsA[id] && pointsB[id]){ ids.push(id); seen.add(id); } });
    Object.keys(pointsB).forEach(id=>{ if(!seen.has(id) && pointsA[id] && pointsB[id]) ids.push(id); });
    return ids;
  }

  function updateMatchedView(){
    const shared = sharedIds();
    if(shared.length < 3){
      viewA = viewB = null;
      return;
    }
    const dimsA = naturalSize('A');
    const dimsB = naturalSize('B');
    if(!dimsA.w || !dimsA.h || !dimsB.w || !dimsB.h){
      viewA = viewB = null;
      return;
    }
    const boxA = paddedBox(boundingBox(pointsA, shared, dimsA), dimsA);
    const boxB = paddedBox(boundingBox(pointsB, shared, dimsB), dimsB);
    if(!boxA || !boxB){
      viewA = viewB = null;
      return;
    }
    const targetW = Math.min(Math.max(boxA.w, boxB.w), dimsA.w, dimsB.w);
    const targetH = Math.min(Math.max(boxA.h, boxB.h), dimsA.h, dimsB.h);
    if(targetW < boxA.w || targetW < boxB.w || targetH < boxA.h || targetH < boxB.h){
      viewA = viewB = null;
      return;
    }
    viewA = alignBox(boxA, targetW, targetH, dimsA);
    viewB = alignBox(boxB, targetW, targetH, dimsB);
  }

  function fitCanvas(){
    const dims = viewB ? {w:viewB.w, h:viewB.h} : naturalSize('B');
    const containerW = wrap.clientWidth || 600;
    const baseW = dims.w || containerW;
    const baseH = dims.h || (baseW*0.75);
    const aspect = baseW ? (baseH/baseW) : 0.75;
    const w = containerW;
    const h = Math.max(1, Math.round(w * aspect));
    canvas.width = w;
    canvas.height = h;
  }

  function toNatural(p, dims){
    if(!p || !dims.w || !dims.h) return null;
    return {x: p.u * dims.w, y: p.v * dims.h};
  }

  function toCanvasPoint(p, dims, view){
    if(!p) return null;
    const nat = toNatural(p, dims);
    if(!nat) return null;
    if(view){
      return {
        x: (nat.x - view.x) / (view.w || 1) * canvas.width,
        y: (nat.y - view.y) / (view.h || 1) * canvas.height
      };
    }
    return {
      x: (nat.x / (dims.w || 1)) * canvas.width,
      y: (nat.y / (dims.h || 1)) * canvas.height
    };
  }

  function transpose(A){ const r=A.length,c=A[0].length; const AT=Array.from({length:c},()=>Array(r).fill(0)); for(let i=0;i<r;i++){ for(let j=0;j<c;j++){ AT[j][i]=A[i][j]; } } return AT; }
  function matMul(A,B){ const r=A.length, c=B[0].length, n=B.length; const R=Array.from({length:r},()=>Array(c).fill(0)); for(let i=0;i<r;i++){ for(let j=0;j<c;j++){ let s=0; for(let k=0;k<n;k++){ s+=A[i][k]*B[k][j]; } R[i][j]=s; } } return R; }
  function matVec(A,v){ const r=A.length, c=A[0].length; const out=Array(r).fill(0); for(let i=0;i<r;i++){ let s=0; for(let j=0;j<c;j++){ s+=A[i][j]*v[j]; } out[i]=s; } return out; }
  function inv4(A){
    const n=4; const M = Array.from({length:n},(_,i)=>[...A[i], ...(function(){const e=Array(n).fill(0); e[i]=1; return e;})()]);
    for(let col=0; col<n; col++){
      let pivot=col; for(let r=col+1;r<n;r++){ if(Math.abs(M[r][col])>Math.abs(M[pivot][col])) pivot=r; }
      const pv=M[pivot][col]; if(Math.abs(pv)<1e-8) return null;
      if(pivot!==col){ const tmp=M[pivot]; M[pivot]=M[col]; M[col]=tmp; }
      for(let j=0;j<2*n;j++) M[col][j]/=M[col][col];
      for(let r=0;r<n;r++){ if(r===col) continue; const f=M[r][col]; for(let j=0;j<2*n;j++){ M[r][j]-=f*M[col][j]; } }
    }
    const inv=Array.from({length:n},()=>Array(n).fill(0));
    for(let i=0;i<n;i++){ for(let j=0;j<n;j++){ inv[i][j]=M[i][j+n]; } }
    return inv;
  }
  function solveSimilarity(srcPts, dstPts){
    const M=[], Y=[];
    for(let i=0;i<3;i++){
      const xs=srcPts[i].x, ys=srcPts[i].y, xd=dstPts[i].x, yd=dstPts[i].y;
      M.push([xs, -ys, 1, 0]); Y.push(xd);
      M.push([ys,  xs, 0, 1]); Y.push(yd);
    }
    const MT = transpose(M); const MTM = matMul(MT,M); const MTY = matVec(MT,Y);
    const inv = inv4(MTM); if(!inv) return null;
    const u = matVec(inv, MTY);
    return {a:u[0], b:u[1], tx:u[2], ty:u[3]};
  }

  function updateStatus(baseAvailable, overlayApplied, pointsUsed, manualActiveFlag){
    if(!stateLoaded){
      statusEl.textContent = 'No saved faces yet. Visit the Manual Landmark Setup to upload the target image, capture your comparison face, and place at least three matching landmarks.';
      statusEl.className = 'small status-warn';
      return;
    }
    const parts = [];
    if(pendingImages){
      parts.push('Saved images are still being prepared. Refresh in a moment after returning from the Manual Landmark Setup page.');
    } else if(storageTruncated){
      parts.push('Stored images were too large to keep. Re-upload smaller versions on the Manual Landmark Setup page so the overlay can display them.');
    }
    if(!refReady){ parts.push('Waiting for target image to load.'); }
    if(!baseAvailable){
      parts.push(captureState.active ? 'Waiting for live capture...' : 'No comparison image detected. Start a capture or freeze a frame in the main tool.');
    }
    if(pointsUsed < 3){
      parts.push('At least three shared landmarks are required for alignment.');
    } else {
      parts.push('Use the manual offset, scale, and rotation controls for fine tuning once aligned.');
      if(manualActiveFlag){
        parts.push('Manual adjustments active — reset to return to the auto alignment.');
      }
    }
    if(overlayApplied){ parts.push('Overlay active — adjust opacity or freeze the frame as needed.'); }
    statusEl.textContent = parts.join(' ');
    const cls = overlayApplied ? 'status-ok' : ((baseAvailable && pointsUsed >= 3) ? 'status-warn' : 'muted');
    statusEl.className = 'small ' + cls;
  }

  function drawOnce(){
    fitCanvas();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const dimsB = naturalSize('B');
    updateMatchedView();
    const baseAvailable = captureState.active ? (captureVideo.readyState >= 2) : baseReady;

    if(baseAvailable){
      if(viewB){
        ctx.drawImage(captureState.active ? captureVideo : baseImg, viewB.x, viewB.y, viewB.w, viewB.h, 0,0, canvas.width, canvas.height);
      } else if(dimsB.w && dimsB.h){
        ctx.drawImage(captureState.active ? captureVideo : baseImg, 0,0, dimsB.w, dimsB.h, 0,0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0,0,canvas.width,canvas.height);
      }
    } else {
      ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    let overlayApplied = false;
    const dimsA = naturalSize('A');
    const ids = controlIds.filter(id=>pointsA[id] && pointsB[id]);
    if(refReady && baseAvailable && ids.length===3){
      const src = ids.map(id=>toNatural(pointsA[id], dimsA));
      const dst = ids.map(id=>toCanvasPoint(pointsB[id], dimsB, viewB));
      if(src.every(Boolean) && dst.every(Boolean)){
        const T = solveSimilarity(src, dst);
        if(T){
          const final = composeManualTransform(T);
          if(final){
            ctx.save();
            ctx.globalAlpha = overlayOpacity;
            ctx.setTransform(final.a, final.b, final.c, final.d, final.e, final.f);
            ctx.drawImage(refImg, 0, 0);
            ctx.restore();
            overlayApplied = true;
          }
        }
      }
    }

    if(showPoints && ids.length){
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#ff2f68';
      ctx.strokeStyle = 'rgba(0,0,0,0.6)';
      ctx.lineWidth = 2;
      ids.forEach(id=>{
        const pt = toCanvasPoint(pointsB[id], dimsB, viewB);
        if(!pt) return;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 5, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      });
      ctx.restore();
    }

    updateStatus(baseAvailable, overlayApplied, ids.length, manualIsActive());
  }

  function tick(){
    drawOnce();
    if(captureState.active){
      captureState.rafId = requestAnimationFrame(tick);
    }
  }

  function startLiveCapture(){
    if(captureState.active) return;
    if(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia){
      alert('Screen capture is not supported in this browser.');
      return;
    }
    navigator.mediaDevices.getDisplayMedia({video:true, audio:false}).then(stream=>{
      captureState.stream = stream;
      captureState.active = true;
      captureVideo.srcObject = stream;
      captureVideo.onloadedmetadata = ()=>{
        captureState.naturalWidth = captureVideo.videoWidth;
        captureState.naturalHeight = captureVideo.videoHeight;
        captureVideo.play().catch(()=>{});
        tick();
      };
      const [videoTrack] = stream.getVideoTracks();
      if(videoTrack){ videoTrack.addEventListener('ended', stopLiveCapture, {once:true}); }
      startBtn.disabled = true;
      stopBtn.disabled = false;
      freezeBtn.disabled = false;
    }).catch(err=>{
      console.error('Live capture failed', err);
      alert('Screen capture failed or was blocked.');
    });
  }

  function stopLiveCapture(){
    if(captureState.stream){ captureState.stream.getTracks().forEach(t=>t.stop()); }
    captureState.stream = null;
    captureState.active = false;
    captureState.naturalWidth = 0;
    captureState.naturalHeight = 0;
    if(captureState.rafId){ cancelAnimationFrame(captureState.rafId); captureState.rafId = 0; }
    captureVideo.srcObject = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    freezeBtn.disabled = true;
    drawOnce();
  }

  function freezeCapture(){
    if(!captureState.active) return;
    if(captureVideo.readyState < 2) return;
    const off = document.createElement('canvas');
    off.width = captureVideo.videoWidth || captureState.naturalWidth || 0;
    off.height = captureVideo.videoHeight || captureState.naturalHeight || 0;
    if(!off.width || !off.height) return;
    const offCtx = off.getContext('2d');
    offCtx.drawImage(captureVideo, 0, 0, off.width, off.height);
    try {
      const dataUrl = off.toDataURL('image/png');
      if(dataUrl){
        baseImg.src = dataUrl;
        baseReady = true;
        stopLiveCapture();
      }
    } catch(err){
      console.error('Freeze capture failed', err);
    }
  }

  function loadState(){
    pendingImages = false;
    storageTruncated = false;
    refReady = false;
    baseReady = false;
    try {
      const raw = window.localStorage.getItem(STATE_KEY);
      if(!raw){
        statusEl.textContent = 'No saved comparator data found. Use the main page to place landmarks first.';
        return;
      }
      const data = JSON.parse(raw);
      if(!data || typeof data !== 'object'){ throw new Error('Invalid saved data'); }
      pointsA = data.pointsA || {};
      pointsB = data.pointsB || {};
      const cp = data.controlPoints || {};
      if(cp.cp1 && cp.cp2 && cp.cp3){ controlIds = [cp.cp1, cp.cp2, cp.cp3]; }
      pendingImages = !!data.pendingImages;
      storageTruncated = !!data.truncated;
      if(data.imgA){ refImg.src = data.imgA; } else { statusEl.textContent = 'Target image missing. Upload it on the main page.'; }
      if(data.imgB){ baseImg.src = data.imgB; baseReady = true; }
      stateLoaded = true;
      drawOnce();
    } catch(err){
      console.error('Failed to load overlay state', err);
      statusEl.textContent = 'Unable to load saved data. Refresh or rebuild the comparison on the main page.';
    }
  }

  refImg.onload = ()=>{ refReady = true; drawOnce(); };
  baseImg.onload = ()=>{ baseReady = true; drawOnce(); };

  opacitySlider.addEventListener('input', ()=>{
    overlayOpacity = clamp(opacitySlider.value, 0, 100) / 100;
    opacityVal.textContent = Math.round(overlayOpacity*100) + '%';
    drawOnce();
  });
  showPointsChk.addEventListener('change', ()=>{ showPoints = showPointsChk.checked; drawOnce(); });
  startBtn.addEventListener('click', startLiveCapture);
  stopBtn.addEventListener('click', stopLiveCapture);
  freezeBtn.addEventListener('click', freezeCapture);
  offsetXSlider.addEventListener('input', updateManualFromInputs);
  offsetYSlider.addEventListener('input', updateManualFromInputs);
  scaleSlider.addEventListener('input', updateManualFromInputs);
  rotationSlider.addEventListener('input', updateManualFromInputs);
  resetAdjustBtn.addEventListener('click', evt=>{ evt.preventDefault(); resetManualAdjustments(); });

  if(window.ResizeObserver){
    const ro = new ResizeObserver(()=>{ drawOnce(); });
    ro.observe(wrap);
  } else {
    window.addEventListener('resize', drawOnce);
  }

  loadManualAdjustments();
  loadState();
})();
</script>
</body>
</html>
